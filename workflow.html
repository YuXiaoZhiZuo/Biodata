<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>工作流展示</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
            color: #ccc;
        }
        
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background-color: rgba(30, 30, 30, 0.8);
            border-radius: 20px;
            padding: 5px;
            z-index: 100;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .control-btn {
            padding: 8px 15px;
            margin: 0 5px;
            border-radius: 15px;
            background-color: #333;
            color: #ccc;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .control-btn:hover {
            background-color: #444;
        }
        
        .control-btn.active {
            background-color: #666;
            color: gold;
        }
        
        .slider-track {
            position: absolute;
            bottom: -5px;
            left: 0;
            height: 3px;
            background-color: gold;
            border-radius: 3px;
            transition: all 0.3s ease;
        }
        
        .node {
            position: absolute;
            width: 200px;
            background-color: #333;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .node.highlighted {
            box-shadow: 0 0 15px gold;
            background-color: #555;
            border: 1px solid gold;
        }
        
        .node-header {
            display: flex;
            padding: 10px;
            border-bottom: 1px solid #444;
        }
        
        .node-icon {
            width: 40px;
            height: 40px;
            border-radius: 5px;
            background-color: #444;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .node.highlighted .node-icon {
            background-color: #666;
        }
        
        .node-title {
            flex-grow: 1;
            font-weight: bold;
        }
        
        .node-content {
            padding: 10px;
        }
        
        .rating-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .rating-label {
            width: 50px;
            font-size: 12px;
        }
        
        .stars {
            display: flex;
        }
        
        .star {
            width: 12px;
            height: 12px;
            margin-right: 2px;
            background-size: contain;
            background-repeat: no-repeat;
        }
        
        .learning-star {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23FFD700" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }
        
        .learning-star.half {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><defs><linearGradient id="half" x1="0" x2="100%" y1="0" y2="0"><stop offset="50%" stop-color="%23FFD700"/><stop offset="50%" stop-color="%23ccc" stop-opacity="0.3"/></linearGradient></defs><path fill="url(%23half)" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }
        
        .learning-star.empty {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23ccc" fill-opacity="0.3" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }
        
        .usage-star {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23FFA500" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }
        
        .usage-star.half {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><defs><linearGradient id="half" x1="0" x2="100%" y1="0" y2="0"><stop offset="50%" stop-color="%23FFA500"/><stop offset="50%" stop-color="%23ccc" stop-opacity="0.3"/></linearGradient></defs><path fill="url(%23half)" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }
        
        .usage-star.empty {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23ccc" fill-opacity="0.3" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>');
        }
        
        .connection {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }
        
        .connection.serial {
            stroke: #666;
            stroke-width: 2;
            fill: none;
        }
        
        .connection.parallel {
            stroke: #555;
            stroke-width: 1;
            stroke-dasharray: 3,3;
            fill: none;
        }
        
        .connection.highlighted {
            stroke: gold;
            stroke-width: 3;
            filter: drop-shadow(0 0 5px gold);
        }
        
        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #graph-container {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="graph-container">
        <div id="controls">
            <div class="slider-track"></div>
        </div>
        <div id="container">
            <svg id="connections"></svg>
        </div>
    </div>

    <script>
        // 配置参数
        const config = {
            zoom: {
                min: 0.2,
                max: 2,
                step: 0.1
            },
            node: {
                width: 200,
                height: 150,
                minDistance: 250 // 节点间最小距离
            },
            layout: {
                repulsion: 500, // 排斥力
                stiffness: 0.1,  // 连接刚度
                damping: 0.6,
                iterations: 50  // 迭代次数
            }
        };
        
        // 全局变量
        let nodes = [];
        let connections = [];
        let workflows = [];
        let highlightedNodes = [];
        let highlightedConnections = [];
        
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let startX, startY;
        let initialOffsetX, initialOffsetY;
        
        // DOM元素
        const graphContainer = document.getElementById('graph-container');
        const container = document.getElementById('container');
        const controls = document.getElementById('controls');
        const sliderTrack = controls.querySelector('.slider-track');
        const connectionsSvg = document.getElementById('connections');
        
        // 初始化
        async function init() {
            // 加载数据
            await loadData();
            
            // 创建工作流控制按钮
            createWorkflowControls();
            
            // 创建节点
            createNodes();
            
            // 自动布局节点
            await performLayout();
            
            // 创建连接
            createConnections();
            
            // 事件监听
            setupEventListeners();
            
            // 初始居中显示
            centerView();
        }
        
        // 加载数据
        async function loadData() {
            try {
                // 加载节点数据
                const nodesResponse = await fetch('json/node.json');
                nodes = await nodesResponse.json();
                
                // 加载连接数据
                const connectionsResponse = await fetch('json/connection.json');
                connections = await connectionsResponse.json();
                
                // 加载工作流数据
                const workflowsResponse = await fetch('json/workflow.json');
                workflows = await workflowsResponse.json();
            } catch (error) {
                console.error('加载数据失败:', error);
            }
        }
        
        // 创建工作流控制按钮
        function createWorkflowControls() {
            controls.innerHTML = '';
            
            workflows.forEach((workflow, index) => {
                const btn = document.createElement('button');
                btn.className = 'control-btn';
                btn.textContent = workflow.name;
                btn.dataset.workflowId = workflow.id;
                
                btn.addEventListener('click', () => {
                    highlightWorkflow(workflow.id);
                    
                    // 更新滑块位置
                    const btnRect = btn.getBoundingClientRect();
                    const controlsRect = controls.getBoundingClientRect();
                    const left = btnRect.left - controlsRect.left;
                    const width = btnRect.width;
                    
                    sliderTrack.style.left = `${left}px`;
                    sliderTrack.style.width = `${width}px`;
                    
                    // 更新按钮状态
                    document.querySelectorAll('.control-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
                
                controls.appendChild(btn);
            });
            
            // 添加滑块轨道
            controls.appendChild(sliderTrack);
            
            // 默认选中第一个工作流
            if (workflows.length > 0) {
                const firstBtn = controls.querySelector('.control-btn');
                if (firstBtn) firstBtn.click();
            }
        }
        
        // 创建节点
        function createNodes() {
            nodes.forEach(node => {
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.dataset.nodeId = node.id;
                
                nodeElement.style.width = `${config.node.width}px`;
                nodeElement.style.transform = `translate(0px, 0px)`;
                
                // 节点头部
                const header = document.createElement('div');
                header.className = 'node-header';

                const icon = document.createElement('img');
                icon.className = 'node-icon';
                icon.src = node.iconPath || 'res/Blendericon.png'; 
                icon.alt = node.name + ' icon';

                const title = document.createElement('div');
                title.className = 'node-title';
                title.textContent = node.name;

                header.appendChild(icon);
                header.appendChild(title);
                
                // 节点内容
                const content = document.createElement('div');
                content.className = 'node-content';
                
                // 学习程度
                const learningItem = document.createElement('div');
                learningItem.className = 'rating-item';
                
                const learningLabel = document.createElement('div');
                learningLabel.className = 'rating-label';
                learningLabel.textContent = '学习程度';
                
                const learningStars = document.createElement('div');
                learningStars.className = 'stars';
                
                for (let i = 0; i < 5; i++) {
                    const star = document.createElement('div');
                    
                    if (node.learning >= i + 1) {
                        star.className = 'star learning-star';
                    } else if (node.learning > i) { // 0.5-1之间
                        star.className = 'star learning-star half';
                    } else {
                        star.className = 'star learning-star empty';
                    }
                    
                    learningStars.appendChild(star);
                }
                
                learningItem.appendChild(learningLabel);
                learningItem.appendChild(learningStars);
                
                // 使用程度
                const usageItem = document.createElement('div');
                usageItem.className = 'rating-item';
                
                const usageLabel = document.createElement('div');
                usageLabel.className = 'rating-label';
                usageLabel.textContent = '使用程度';
                
                const usageStars = document.createElement('div');
                usageStars.className = 'stars';
                
                for (let i = 0; i < 5; i++) {
                    const star = document.createElement('div');
                    
                    if (node.usage >= i + 1) {
                        star.className = 'star usage-star';
                    } else if (node.usage > i) {
                        star.className = 'star usage-star half';
                    } else {
                        star.className = 'star usage-star empty';
                    }
                    
                    usageStars.appendChild(star);
                }
                
                usageItem.appendChild(usageLabel);
                usageItem.appendChild(usageStars);
                
                // 评价
                const comment = document.createElement('div');
                comment.style.marginTop = '10px';
                comment.style.fontSize = '12px';
                comment.textContent = node.comment || '暂无评价';
                
                content.appendChild(learningItem);
                content.appendChild(usageItem);
                content.appendChild(comment);
                
                nodeElement.appendChild(header);
                nodeElement.appendChild(content);
                
                container.appendChild(nodeElement);
            });
        }
        
        // 执行自动布局
        function performLayout() {
            return new Promise(resolve => {
                const nodeElements = Array.from(document.querySelectorAll('.node'));
                if (nodeElements.length === 0) return resolve();
                
                // 初始化位置 - 圆形布局
                const radius = Math.min(800, 150 * nodes.length);
                const center = { x: 0, y: 0 };
                const angleStep = (2 * Math.PI) / nodes.length;
                
                const nodePositions = {};
                nodes.forEach((node, i) => {
                    const angle = i * angleStep;
                    nodePositions[node.id] = {
                        x: center.x + radius * Math.cos(angle),
                        y: center.y + radius * Math.sin(angle),
                        vx: 0,
                        vy: 0
                    };
                });
                
                // 力导向布局迭代
                for (let iter = 0; iter < config.layout.iterations; iter++) {
                    // 计算排斥力
                    nodes.forEach(node1 => {
                        nodes.forEach(node2 => {
                            if (node1.id === node2.id) return;
                            
                            const pos1 = nodePositions[node1.id];
                            const pos2 = nodePositions[node2.id];
                            
                            const dx = pos2.x - pos1.x;
                            const dy = pos2.y - pos1.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const minDistance = config.node.minDistance;
                            
                            if (distance > 0) {
                                // 更强的短距离排斥力
                                const repulsionForce = config.layout.repulsion / Math.max(distance * distance, 100);
                                
                                // 如果距离小于最小距离，增加排斥力
                                if (distance < minDistance) {
                                    const extraForce = (minDistance - distance) * 5;
                                    pos1.vx -= (dx / distance) * (repulsionForce + extraForce);
                                    pos1.vy -= (dy / distance) * (repulsionForce + extraForce);
                                } else {
                                    pos1.vx -= (dx / distance) * repulsionForce;
                                    pos1.vy -= (dy / distance) * repulsionForce;
                                }
                            }
                        });
                    });
                    
                    // 计算连接吸引力
                    connections.forEach(conn => {
                        const fromPos = nodePositions[conn.from];
                        const toPos = nodePositions[conn.to];
                        
                        if (fromPos && toPos) {
                            const dx = toPos.x - fromPos.x;
                            const dy = toPos.y - fromPos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance > 0) {
                                const attractionForce = distance * config.layout.stiffness;
                                fromPos.vx += (dx / distance) * attractionForce;
                                fromPos.vy += (dy / distance) * attractionForce;
                                toPos.vx -= (dx / distance) * attractionForce;
                                toPos.vy -= (dy / distance) * attractionForce;
                            }
                        }
                    });
                    
                    // 更新位置
                    nodes.forEach(node => {
                        const pos = nodePositions[node.id];
                        
                        // 应用速度
                        pos.vx *= config.layout.damping;
                        pos.vy *= config.layout.damping;
                        pos.x += pos.vx;
                        pos.y += pos.vy;
                        
                        // 限制速度
                        const speed = Math.sqrt(pos.vx * pos.vx + pos.vy * pos.vy);
                        const maxSpeed = 5;
                        if (speed > maxSpeed) {
                            pos.vx = (pos.vx / speed) * maxSpeed;
                            pos.vy = (pos.vy / speed) * maxSpeed;
                        }
                    });
                }
                
                // 应用最终位置
                nodeElements.forEach(nodeElement => {
                    const nodeId = nodeElement.dataset.nodeId;
                    const pos = nodePositions[nodeId];
                    if (pos) {
                        nodeElement.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
                    }
                });
                
                resolve();
            });
        }
        
        // 创建连接
        function createConnections() {
            connectionsSvg.innerHTML = '';
            
            connections.forEach(conn => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.className.baseVal = `connection ${conn.type}`;
                path.dataset.connectionId = conn.id;
                path.dataset.from = conn.from;
                path.dataset.to = conn.to;
                
                connectionsSvg.appendChild(path);
                
                updateConnectionPath(conn.id);
            });
        }
        
        // 更新连接路径
        function updateConnectionPath(connectionId) {
            const path = connectionsSvg.querySelector(`[data-connection-id="${connectionId}"]`);
            if (!path) return;
            
            const fromId = path.dataset.from;
            const toId = path.dataset.to;
            
            const fromNode = document.querySelector(`[data-node-id="${fromId}"]`);
            const toNode = document.querySelector(`[data-node-id="${toId}"]`);
            
            if (!fromNode || !toNode) return;
            
            // 获取节点在容器中的位置（考虑transform）
            const fromTransform = getComputedStyle(fromNode).transform;
            const toTransform = getComputedStyle(toNode).transform;
            
            // 解析transform矩阵
            const fromMatrix = fromTransform !== 'none' ? 
                fromTransform.match(/^matrix\((.+)\)$/)[1].split(', ').map(Number) : 
                [1, 0, 0, 1, 0, 0];
            
            const toMatrix = toTransform !== 'none' ? 
                toTransform.match(/^matrix\((.+)\)$/)[1].split(', ').map(Number) : 
                [1, 0, 0, 1, 0, 0];
            
            // 计算节点中心点
            const fromX = fromMatrix[4] + config.node.width;
            const fromY = fromMatrix[5] + config.node.height / 2;
            
            const toX = toMatrix[4];
            const toY = toMatrix[5] + config.node.height / 2;
            
            // 创建曲线路径
            const dx = toX - fromX;
            const dy = toY - fromY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const curveIntensity = Math.min(distance * 0.3, 150);
            
            let pathData;
            
            if (path.classList.contains('serial')) {
                pathData = `M ${fromX} ${fromY} 
                        C ${fromX + curveIntensity} ${fromY}, 
                            ${toX - curveIntensity} ${toY}, 
                            ${toX} ${toY}`;
            } else {
                const midX = (fromX + toX) / 2;
                pathData = `M ${fromX} ${fromY} 
                        C ${midX} ${fromY}, 
                            ${midX} ${toY}, 
                            ${toX} ${toY}`;
            }
            
            path.setAttribute('d', pathData);
        }
        
        // 高亮工作流
        function highlightWorkflow(workflowId) {
            // 移除之前的高亮
            highlightedNodes.forEach(id => {
                const node = document.querySelector(`[data-node-id="${id}"]`);
                if (node) node.classList.remove('highlighted');
            });
            
            highlightedConnections.forEach(id => {
                const conn = connectionsSvg.querySelector(`[data-connection-id="${id}"]`);
                if (conn) conn.classList.remove('highlighted');
            });
            
            // 获取新的高亮项
            const workflow = workflows.find(w => w.id === workflowId);
            if (!workflow) return;
            
            highlightedNodes = workflow.nodeIds || [];
            highlightedConnections = workflow.connectionIds || [];
            
            // 应用新的高亮
            highlightedNodes.forEach(id => {
                const node = document.querySelector(`[data-node-id="${id}"]`);
                if (node) node.classList.add('highlighted');
            });
            
            highlightedConnections.forEach(id => {
                const conn = connectionsSvg.querySelector(`[data-connection-id="${id}"]`);
                if (conn) conn.classList.add('highlighted');
            });
        }
        
        // 设置事件监听器
        function setupEventListeners() {
            // 鼠标滚轮缩放
            graphContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const delta = -Math.sign(e.deltaY); // 标准化delta值
                const zoomIntensity = 0.1;
                
                const oldScale = scale;
                scale = Math.min(config.zoom.max, Math.max(config.zoom.min, scale * (1 + delta * zoomIntensity)));
                
                // 获取鼠标相对于容器的位置
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // 计算鼠标在内容中的位置（考虑当前偏移和缩放）
                const contentX = (mouseX - offsetX) / oldScale;
                const contentY = (mouseY - offsetY) / oldScale;
                
                // 调整偏移量以保持鼠标位置不变
                offsetX = mouseX - contentX * scale;
                offsetY = mouseY - contentY * scale;
                
                updateTransform();
            });
            
            // 鼠标拖动
            graphContainer.addEventListener('mousedown', (e) => {
                if (e.button === 0 || e.button === 1) { // 左键或中键
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    initialOffsetX = offsetX;
                    initialOffsetY = offsetY;
                    graphContainer.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    offsetX = initialOffsetX + (e.clientX - startX);
                    offsetY = initialOffsetY + (e.clientY - startY);
                    updateTransform();
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                if (isDragging && (e.button === 0 || e.button === 1)) {
                    isDragging = false;
                    graphContainer.style.cursor = 'grab';
                    e.preventDefault();
                }
            });
            
            // 防止中键滚动
            graphContainer.addEventListener('auxclick', (e) => {
                if (e.button === 1) e.preventDefault();
            });
            
            // 窗口大小变化时更新连接
            window.addEventListener('resize', () => {
                connections.forEach(conn => {
                    updateConnectionPath(conn.id);
                });
            });
        }
        
        // 更新变换
        function updateTransform() {
            container.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
            
            // 更新所有连接路径
            connections.forEach(conn => {
                updateConnectionPath(conn.id);
            });
        }
        
        // 居中显示所有节点
        function centerView() {
            const nodeElements = document.querySelectorAll('.node');
            if (nodeElements.length === 0) return;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            nodeElements.forEach(node => {
                const transform = node.style.transform.match(/translate\(([-\d.]+)px, ([-\d.]+)px\)/);
                if (!transform) return;
                
                const x = parseFloat(transform[1]);
                const y = parseFloat(transform[2]);
                
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + config.node.width);
                maxY = Math.max(maxY, y + config.node.height);
            });
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            const containerWidth = graphContainer.clientWidth;
            const containerHeight = graphContainer.clientHeight;
            
            // 计算适合的缩放比例
            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;
            
            const scaleX = containerWidth / (contentWidth + 200);
            const scaleY = containerHeight / (contentHeight + 200);
            
            scale = Math.min(config.zoom.max, Math.max(config.zoom.min, Math.min(scaleX, scaleY)));
            
            // 计算偏移量使内容居中
            offsetX = containerWidth / 2 - centerX * scale;
            offsetY = containerHeight / 2 - centerY * scale;
            
            updateTransform();
        }
        
        // 初始化应用
        init();
    </script>
</body>
</html>